# 优先顺序

>  from>where>select>group by>having>order by



# [178. 分数排名](https://leetcode-cn.com/problems/rank-scores/)

```mysql
# 178 题 分数排名
CREATE TABLE `scores_ranking`
(
    `id`    INT(10) NOT NULL PRIMARY KEY COMMENT '主键',
    `score` DOUBLE(5, 2) DEFAULT NULL COMMENT '分数'
) ENGINE = INNODB
  DEFAULT CHARSET = utf8 COMMENT = '分数排名';
# 将 字段名称修改
ALTER TABLE `scores_ranking`
    CHANGE `name` `score` DOUBLE(5, 2) NOT NULL COMMENT '分数';
# 修改主键为自增
ALTER TABLE `scores_ranking`
    MODIFY id INT(10) AUTO_INCREMENT;
# 填充数据
INSERT INTO `scores_ranking` (id, score)
VALUES ('', 3.5),
       ('', 3.6),
       ('', 4),
       ('', 3.85),
       ('', 4),
       ('', 3.65);
/* 编写一个 SQL 查询来实现分数排名。
如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。*/
# 方法一 排名函数
SELECT score,
       dense_rank() over (order by Score desc) AS `Rank`
FROM scores_ranking;
# 方法二 直取
SELECT score,
       (SELECT count(DISTINCT score) FROM scores_ranking WHERE score >= s.score) AS 'Rank'
FROM scores_ranking s
ORDER BY Score DESC;
# 优化 内部变量 join子查询效率更高些
select t.score Score,t.rank `Rank` from scores_ranking join
( SELECT p.score score , @rank:=@rank+1 `rank` FROM
        (SELECT distinct(score) score FROM scores_ranking ORDER BY score DESC) p , (SELECT @rank:=0 ) q)  AS t
on scores_ranking.score = t.score
order by score desc;
# 优化 内部变量 解决返回浮点数问题，使用cast
SELECT Score, CAST(CASE
WHEN @pre = Score THEN @rk + 0
WHEN @pre := Score THEN   @rk := @rk + 1
ELSE  @rk := @rk + 1
END AS SIGNED) AS `Rank`
FROM scores_ranking, (SELECT @pre := NULL, @rk := 0) AS init
ORDER BY Score DESC;
```

[参考地址](https://www.cnblogs.com/caicaizi/p/9803013.html)